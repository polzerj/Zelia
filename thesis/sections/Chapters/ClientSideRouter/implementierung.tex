\hthree{Implementierung}

"Frontend Routing" ist, ein bisschen komplizierter zu implementieren. Wenn man kein Framework wie \zb: Angular verwendet, muss man praktisch alles selbst implementieren. Bei \ZELIA\ wurde kein Framework verwendet, sondern  ein eigenes kleines "Frontend Service" geschrieben, um perfekt an die Bedürfnisse von \ZELIA\ angepasst zu sein.

Aufteilen kann man die Client Bibliothek wie schon gesagt in zwei Teile: Das Komponentensystem und den Client-Side-Router. Das Komponentensystem wurde vorher schon beschrieben (siehe Kapitel WebComponents \ref{sec:webcomponents}). Beide Teile der Bibliothek haben keine Abhängigkeiten und können getrennt voneinander laufen. Sie sind beide für den Anwendungsfall in \ZELIA\ entwickelt, können aber auch problemlos einzeln für andere Web-Applikationen verwendet werden.

Wie vorhin erwähnt wird bei \ZELIA\ ein einfaches "index.html" verwendet, um das Skript zu laden, welches sich um die gesamte Seite kümmert. Zusätzlich ist ein leerer Container mit dem Namen "app" definiert, der sich auf der Webseite befindet. Dieser Container wird vom Client-Side-Router verwendet um Seiten dynamisch in die Hauptseite, die nie wirklich verlassen wird, hineinzuladen. Wenn das Skript vom Browser gestartet wird, erstellt \ZELIA\ ein Router Objekt mit folgenden Schnittstellen:

\typescript{code/CSRouter/interface.ts}{Schnittstellen der "Router" Klasse}

Als "Root-Element" wird dem Konstruktor der "app"-Container mitgegeben. Der Inhalt von diesem Container wird jedes Mal, wenn eine neue Seite geladen wird, gelöscht und mit den neuen Daten befüllt. Somit gibt es die Möglichkeit statische Inhalte einzubauen, wie zum Beispiel eine Kopfzeile oder Impressum, ohne sie in jede Seite hinzufügen zu müssen.

Nachdem der Router erstellt wurde, werden die notwendigen Routen initialisiert:

\typescript[initRoutes]{code/CSRouter/init.ts}{Initialisierung der Routen}


Der erste Parameter ist der Pfad und der Zweite ist der Controller, welcher ausgeführt wird, wenn der Pfad aufgerufen wird. Ein Controller ist in diesem Fall eine einfache Methode, welche den App-Container befüllt.

\typescript{code/CSRouter/hw_example.ts}{Beispiel einer "Hello World"-Seite}

Im Codebeispiel \ref{initRoutes}, Zeile fünf bis sieben, wird der Pfadeintrag "{\ttfamily /room/:roomNumber}" verwendet. Der Router leitet somit alle "{\ttfamily /room/...}" auf den verknüpften Controller um. Wenn dieser aufgerufen wird, bekommt er als Parameter die Werte von dem Platzhaltern mitgeliefert:

\typescript{code/CSRouter/placeholder.ts}{Beispiel "Controller" mit Platzhalter}

Nachdem alle Routen initialisiert wurden, führt der Router den Controller aus, welcher mit dem aktuellen Pfad aus der Suchleiste verknüpft ist. Damit werden alle  Inhalte der angeforderten Seite dargestellt. Somit ist es möglich, dass man den Pfad manuell eingeben kann und nicht immer auf der Anfangsroute "{\ttfamily /}" startet.

Wenn ein Link ausgewählt wird, fängt \ZELIA\ die Anfrage an den Server ab und verwaltet das Umleiten selbst:

\typescript{code/CSRouter/redirect.ts}{Umleitung in einem Event}

Im  Hintergrund wird jedes Mal beim Umleiten ein Eintrag in den Verlauf hinzugefügt. Bei diesem Eintrag wird der besuchte Pfad gespeichert. Der Browser speichert den Verlauf einer Seite als Stack. Dadurch kann man nur oben Elemente hinzufügen oder das Oberste herunternehmen. Somit kann man das Event "onPop" welches der Browser feuert, abfangen und selbst mit dem Router umleiten:

\typescript[code:routerhistory]{code/CSRouter/history.ts}{Abfangen und Umleiten, wenn der Verlauf geändert wird}

Im Codebeispiel \ref{code:routerhistory} steht das zweite Argument für "Silent History", womit kein Eintrag in den Verlauf gemacht wird.

Wenn der Router auf einen Pfad umleiten soll den er nicht kennt, dann lädt er die 404-"Not Found" Seite. Diese Seite besteht aus einer einzelnen Komponente, nämlich der 404-Komponente.

\typescript{code/CSRouter/notfound.ts}{Laden der 404 Komponente in die Fehlerseite}

Mit all den oben beschriebenen Maßnahmen kann der \ZELIA\ Client-Service zwischen verschiedenen logischen Seiten wechseln, ohne jemals die eigentliche Seite zu verlassen.
