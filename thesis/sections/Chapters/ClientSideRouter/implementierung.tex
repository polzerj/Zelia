\hthree{Implementierung}

Wie gerade erwähnt ist "Frontend-Routing" oder auch "Client-Side-Routing" bisschen komplizierter zu implementieren da, wenn man kein Framework, wie z.B.: Angular verwendet, muss man praktisch alles selbst implementieren. Wir haben uns aber trotzdem dazu entschieden kein Framework zu verwenden und unsere eigenes kleines Frontend Service zu schrieben da wir in Erfahrung gebracht haben, dass Frontend-Frameworks meist viel zu groß und komplex sind für unsere Anforderungen.

Aufteilen kann man unsere Client Bibliothek wie schon gesagt in 2 Teile: Das Komponentensystem und den Client-Side-Router. Das Komponentensystem wurde oben schon beschrieben (siehe Kapitel WebComponents). Beide Teile der Bibliothek haben keine Abhängigkeiten und können getrennt voneinander laufen. Sie sind beide für den Anwendungsfall an ZELIA entwickelt, können aber auch problemlos auch einzeln für andere Web-Applikationen verwendet werden.

Wie vorhin erwähnt wird auch bei ZELIA ein Einfaches "index.html" verwendet, um das Skript zu laden, welches sich um die gesamte Seite kümmert. Zusätzlich ist ein leerer Container mit dem Namen "app" definiert, der sich auf der Webpage befindet. Dieser Container wird vom Client-Side-Router verwendet um Seiten dynamisch in die Hauptseite, die nie wirklich verlassen wird, reinzuladen. Wenn das Skript vom Browser gestartet wird, erstellt ZELIA ein Router Objekt mit folgenden Schnittstellen:

\typescript{code/CSRouter/interface.ts}{Schnittstellen der "Router" Klasse}

Als "Root-element" wird im Konstruktor der "app"-Container mitgegeben. Der Inhalt von diesem Container wird jedes Mal, wenn eine "neue Seite" geladen wird, gelöscht und mit den neuen Daten befüllt. Somit gibt es die Möglichkeit statische Inhalte einzubauen, wie zum Beispiel eine Kopfzeile oder Impressum, ohne sie in jede Seite hinzufügen zu müssen.

Nachdem der Router erstellt wurde, werden die notwendigen Routen initialisiert:

\typescript{code/CSRouter/init.ts}{Initialisierung der Routen}

Der erste Parameter ist Pfad und der Zweite ist der Controller, welcher ausgeführt wird, wenn der Pfad aufgerufen wird. Ein Controller ist in unserem Fall eine einfache Methode, welche den App-Container befüllt.

\typescript{code/CSRouter/hw_example.ts}{Beispiel einer "Hello World"-Seite}

% Code und Ref statt Bild 20 
In dem Codebeispiel (referenz zu Bild 20)  3. bis 5. Pfadeintrag wird ein "/room/:roomNumber" verwendet. Der Router leitet somit alle "/room/..." auf den verknüpften Controller um und wenn dieser Aufgerufen wird, bekommt er als Parameter die Werte von dem Platzhaltern mitgeliefert:

\typescript{code/CSRouter/placeholder.ts}{Beispiel "Controller" mit Platzhalter}

Am Ende, nachdem alle Routen initialisiert wurden, sagen wir dem Router, wohin er Routen soll, also welcher Controller ausgeführt werden soll, um die nötigen Inhalte dazustellen. Dafür wird der Pfad verwendet, welcher in der Eingabezeile des Browsers mitgegeben wird. Somit ist es möglich das man den Pfad manuell eingeben kann und nicht immer auf der Anfangsroute "/" startet.

Wenn ein Link gedrückt wird, fängt ZELIA die Anfrage an dem Server ab und verwaltet das Umleiten selbst:

\typescript{code/CSRouter/redirect.ts}{Umleitung in einem Event}

Im  Hintergrund wird jedes Mal beim Umleiten ein Eintrag in den Verlauf gemacht. Bei diesem Eintrag wird der besuchte Pfad gespeichert. Der Browser speichert den Verlauf einer Seite als Stapel, sprich man kann nur oben hinzufügen und das oberste Element runternehmen. Somit kann man das Event "onPop" welches der Browser wirft, abfangen und selbst mit dem Router Umleiten:

\typescript{code/CSRouter/history.ts}{Abfangen und Umleiten wenn der Verlauf geändert wird}

Das Zweite Argument steht für "Silent History", womit kein Eintrag in den Verlauf gemacht wird.

Mit diesen Voraussetzungen kann der ZELIA Client-Service zwischen verschiedenen Seiten logisch wechseln ohne, jemals die eigentliche Seite zu verlassen.