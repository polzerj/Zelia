\htwo{Client Side Router}
\label{sec:csrouter}
\sectionauthor{Julian Kusternigg}
\hthree{Allgemeines}

\hfour{Einleitung}

In der Netzwerktechnik ist "Routing" der Vorgang, um einen Weg für Daten zu finden. In der Webentwicklung ist das ziemlich ähnlich. Jede Seite hat einen bestimmten Pfad, eine Route, \zb:

{\ttfamily https://zelia/home} oder {\ttfamily .../room/S1308}

In diesen Fällen wären "{\ttfamily /home}" und "{\ttfamily /room/S1308}" zwei verschiedene Routen. Früher hat man am Webserver, also an dem Server, der die Daten zur Verfügung stellt, ein Verzeichnis gehabt, das alle möglichen Pfade abbildet.

\begin{figure}[H]
  
  \begin{singlespace}
  \begin{lstlisting}
www/
  > home/
  > room/
    > S1308/
    > ...
    \end{lstlisting}
  \end{singlespace}
    \caption{Ordnerstruktur eines Webservers}
\end{figure}

Diese Art von Webserver stellt statische Webseiten zur Verfügung. Statisch, weil die Daten, \zb: das "{\ttfamily index.html}", nicht geändert werden, sondern so, wie sie am Server liegen, dem Client geschickt werden. Dies hat den Vorteil, dass der Server kaum Ressourcen verbraucht. In jedem dieser Verzeichnisse kann man ein "{\ttfamily index.html}" finden, welches der Webserver schickt, wenn einer dieser Pfade vom Browser angefragt wird. Das Problem, welches dabei auftritt ist, dass es für jeden Raum ein fertiges "{\ttfamily index.html}" im richtigen Pfad geben muss.

Als Lösung für dieses Problem gibt es sogenannte Router, die wissen was zu tun ist, wenn eine Route angefragt wird. Somit kann man die statische Hierarchie auflösen und auf jede Anfrage individuell reagieren. In der Webentwicklung werden diese Steuerungsprogramme, die auf Anfragen reagieren, meist "Controller" genannt. Ein "Controller" bekommt somit eine Anfrage und liefert eine Antwort, welche im Zusammenhang von vorher das "{\ttfamily index.html}" ist. Dabei ist aber wichtig zu erwähnen, dass der Inhalt des "{\ttfamily index.html}", also der Antworttext, modifiziert werden kann. So kann ein Router beispielsweise alle Routen die aus "{\ttfamily /room/...}" bestehen an einen "Controller" weitergeben, der dem Client jeweils andere Informationen zurückgibt.

Nochmal kurz zusammengefasst: Router sind in der Webentwicklung dazu da, um Routen (Pfade) aufzulösen und an den richtigen "Controller" weiterzureichen. "Controller" liefern dann individuelle Ergebnisse auf jeweilige Anfragen.

\hfour{Backend Routing}

Backend Routing wird der Vorgang genannt, bei dem das Routing im Backend der Applikation, also Serverseitig, gemacht wird. Beispiele dafür wären wie oben genannt, statische Webserver oder dynamische Webserver, welche mit "Controllern" arbeiten.

\hfour{Frontend Routing}

Frontend Routing, auch "Client-Side-Routing" genannt, bedeutet, dass das Routing zum Client verschoben wird. Die Anfragen werden direkt im Browser verarbeitet. So muss ein Webserver nur eine einzige Seite zur Verfügung stellen, die der Client lädt.

Im Beispiel von vorhin müsste der Webserver nur ein "{\ttfamily index.html}" hosten, welches der Client, egal welche Route er besucht, herunterlädt. Das ist meist eine minimale HTML Seite, die eine Javascript-Datei einbindet. Dieses Skript schaut dann, auf welchem Pfad es sich befindet und holt, falls nötig, Informationen von einer API, um eine Seite aufzubauen. Das "{\ttfamily index.html}" wird nur ein Mal zu Beginn heruntergeladen. Entweder wenn die Webseite besucht wird oder wenn man die URL manuell im Browser eingibt. Bei jedem Link auf der Webseite werden nur die notwendigen Infos nachgeladen und angezeigt. Zusätzlich wird mit Hilfe der "History-API" ein Eintrag in den Verlauf gemacht, sodass man mit der "Zurücktaste" auf die zuvor besuchten Pfade zurückspringen kann.

Obwohl die Seite eigentlich nie verlassen wird, ändert der Browser den Verlauf und den Pfad, der in der URL-Eingabebox steht. Somit ist es möglich, das Routing komplett in den Browser zu verschieben.

\hfour{Vorteile des Client-Side-Routers}

Einer der größten Vorteile ist, dass die eigentliche Webseite, also das "{\ttfamily index.html}", praktisch überall bereitgestellt werden kann. Es benötigt kaum Ressourcen solche statischen Seiten zur Verfügung zu stellen. Die Browser auf den Geräten, mit denen die Seite aufgerufen wird, haben die komplexere Aufgabe, die Seite richtig darzustellen. Mit Computern und Smartphones ist das allerdings in der heutigen Zeit auch kein Problem mehr.

Es ist oft schneller, nur notwendige Infos nachzuladen, als eine ganze Webseite herunterladen zu müssen. Vor allem wenn man im Browser heruntergeladene Daten in Caches zwischenspeichert. Somit müssen am Anfang meist mehr Daten geladen werden, dafür hat man dann beim Wechseln der Seite kaum Ladezeiten. Zusätzlich kann man Musterwerte verwenden oder einen Ladebildschirm anzeigen, wenn die individuellen Werte noch nachgeladen werden. So kann der Browser schon mal Inhalte darstellen und es muss nicht gewartet werden, bis eine gesamte Seite am Server zusammengestellt und geschickt wird.

Die Daten, welche für die Darstellung benötigt werden, werden von "API-Servern" zur Verfügung gestellt. Auf den API-Servern kann man zentral die Schnittstellen definieren und überwachen, welche Daten zugänglich sind. Durch diese vordefinierten Schnittstellen sind Server und Client besser voneinander getrennt. Würden die HTML Seiten am Server generiert werden, kann dies bei komplexen Anwendungen schnell unübersichtlich werden.

\input{sections/Chapters/ClientSideRouter/implementierung.tex}