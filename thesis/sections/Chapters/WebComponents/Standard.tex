\hthree{Der "Web Component" Standard}

Web Components ermöglichen es den gleichen Code des Clients an mehreren Stellen zu verwenden. Dazu wurden drei neue Technologien \cite{MDNWebComponents} eingeführt:

\begin{itemize}
    \item Custom Elements
    \item Shadow DOM
    \item HTML Templates
\end{itemize}


\hfour{Custom Elements}

\hfive{Erstellung eines Custom Elements}

Custom Elements sind ES6 Klassen, welche von der Klasse "HTMLElement" erben. "ES6", ausgeschrieben "ECMA Script 6", ist der Standard, welcher Klassen in Javascript hinzugefügt hat.\cite{MDNes6Classes}

\typescript{code/WebComponents/one.ts}{Erstellung einer Custom Element Klasse}

Diese Klasse kann nun als Custom Element registriert werden. Dabei muss der Name des Elements vergeben werden, welcher einen Bindestrich enthalten muss.

\typescript{code/WebComponents/two.ts}{Registrierung des Custom Elements}

Wenn das Custom Element registriert ist, kann es mit dem vergebenen Namen im HTML verwendet werden.

\html{code/WebComponents/three.html}{Verwendung des Custom Elements im HTML}

\hfive{Lifecycle-Methoden \cite{MDNWebCustomElements}}

Um den Lebenszyklus eines Custom Elements besser zu kontrollieren, gibt es sogenannte "lifecycle callbacks". Diese "lifecycle callbacks" sind spezielle Methoden in einer Klasse, welche von der API der Custom Elements aufgerufen werden.

Der "connectedCallback" wird aufgerufen, wenn das Element in das DOM eingefügt wird. Das DOM (Document Object Model) ist eine Programmierschnittstelle über die man auf die einzelnen HTML Elemente zugreifen kann. \cite{MDNDOM} Darin können zum Beispiel Event-Listeners registriert werden.

\typescript{code/WebComponents/four.ts}{"connectedCallback" Beispiel}
   
Der "disconnectedCallback" ist das Gegenstück zum "connectedCallback" und wird beim Verlassen des DOMs aufgerufen. Darin sollten etwaige "Event Listeners" entfernt werden, um die nicht mehr benötigten Ressourcen freizugeben und dadurch Speicher und CPU-Zeit zu sparen.  

\typescript{code/WebComponents/five.ts}{"disconnectedCallback" Beispiel}

Der "adoptedCallback" wird jedes Mal aufgerufen, wenn das Element auf eine neue Seite verschoben wird.

\typescript{code/WebComponents/six.ts}{"adoptedCallback" Beispiel}

Der "attributeChangedCallback" Lifecycle-Hook wird jedes Mal aufgerufen, wenn ein Attribut des Custom Elements geändert wird. Allerdings muss dafür eine Liste an Attributnamen von der statischen Eigenschaft "observedAttributes" zurückgegeben werden. 
    
Der "attributeChangedCallback" nimmt drei Parameter:
\begin{itemize}
    \item Name: Name des Attributes
    \item Old Value: Den Wert vor der Änderung
    \item New Value: Der neue, aktuelle Wert 
\end{itemize}

\typescript{code/WebComponents/seven.ts}{"attributeChangedCallback" Beispiel}

\pagebreak
\hfour{Shadow DOM}

Unter DOM (Document Object Model) versteht man die Programmierschnittstelle, mit der auf die Elemente einer Webseite zugegriffen werden kann, um deren Inhalt und Darstellung zu verändern. \cite{MDNDOM}

Ein Shadow DOM ist ein Ast im DOM-Baum innerhalb der Webseite, welcher separat von der restlichen Seite gerendert wird. Dadurch kann auch auf Custom Elements ein Style in Style-Tags erstellt werden, ohne das Design der restlichen Seite zu beeinflussen. \cite{MDNShadowRoot}

Um einen Shadow Root zu erstellen, muss lediglich die Methode "attachShadow" aufgerufen werden. \cite{MDNShadowRoot}

\typescript{code/WebComponents/eight.ts}{Erstellung eines Shadow Roots}

Der "Mode" muss auf "open" gesetzt werden, damit der "ShadowRoot" befüllt werden kann. Nun kann mit "this.shadowRoot" auf den "ShadowRoot" innerhalb des Custom Components zugegriffen werden.
\cite{MDNShadowRoot}

\pagebreak
\hfour{HTML Templates}

Um das Custom Element mit Inhalten zu füllen, gibt es in HTML den "template"-Tag. Dieser wird nicht im DOM gerendert, kann aber trotzdem mit Javascript referenziert werden. \cite{MDNtemplate}

\html{code/WebComponents/nine.html}{Erstellung eines HTML Template}

Damit das Template als Custom Element gerendert wird, muss der Content in das dieses, oder dessen Shadow DOM kopiert werden.

\typescript{code/WebComponents/ten.ts}{Kopieren des Template in das Custom Element}

Um den Inhalt der Components dynamisch zu machen, gibt es den HTML "Slot"-Tag. 
Dieser ermöglicht es Inhalte an die Components weiterzugeben. 
Dafür muss allerdings ein Shadow DOM verwendet werden. 
Ein Slot wird immer mit seinem Namen referenziert. 
Wenn bei einem Child-Node eines Custom Elements kein Slotname angegeben ist, dann wird dieses Node im Slot ohne Namen gerendert. 
Ein Node versteht sowohl ein HTML-Element, als auch ein Text-Node, welches direkt in das Element eingefügt wird. 
Wird für einen Slot kein Node gesetzt, dann wird der Inhalt des Slots als Standardwert verwendet. 
\cite{MDNSlots}

\pagebreak
\hfive{Beispiel eines Webcomponents mit Slots und Shadow DOM}

\typescript[code:WebComponentExampleJS]{code/WebComponents/eleven.ts}{Web Component Beispiel (Javascript)}


\html[code:WebComponentExampleHTML]{code/WebComponents/twelve.html}{Web Component Beispiel (HTML)}

Die Codebeispiele \ref{code:WebComponentExampleJS} und \ref{code:WebComponentExampleHTML} erzeugen folgende Ausgabe:

{\ttfamily Hi Universe!!}